// Auto-generated by wxEC - Tue Jul 13 00:12:08 2010
// Do not edit this file - it will be overwritten on next pass
// Make any necessary changes to the source file:
// c:\pkg\wx\wxEC\enums.e

#include "enums.h"
#include <string.h>
/*============================================================================*/
/**** Enum Class: EState ****/
const int EState::m_iMapSize = 4;
EState::Map_t EState::m_Map[] =
{
  {Unknown, "Unknown"},
  {Solid, "Solid Matter"},
  {Liquid, "Liquid Matter "},
  {Gas, "Vapour"} 
};

/*----------------------------------------------------------------------------*/
EState::EState()
{
  m_Enum = Unknown;
}

/*----------------------------------------------------------------------------*/
EState::~EState()
{
}

/*----------------------------------------------------------------------------*/
EState::Enum EState::operator=(int i)
{
  m_Enum = AsEnum(i);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
EState::operator int () const
{
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
EState::Enum EState::operator=(const char* sz)
{
  m_Enum = AsEnum(sz);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
bool EState::operator==(const char* sz)
{
  return m_Enum == AsEnum(sz);
}

/*----------------------------------------------------------------------------*/
EState::operator const char* () const
{
  return AsName(m_Enum);
}

/*----------------------------------------------------------------------------*/
EState::Enum EState::AsEnum(const char* sz)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(strcmp(sz, m_Map[i].szDescription)==0)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
EState::Enum EState::AsEnum(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
const char* EState::AsName(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return m_Map[i].szDescription;
    }
  }
  return m_Map[0].szDescription;
}

/*----------------------------------------------------------------------------*/
bool EState::GetMap(int iIndex, int& iValue, const char*& szDescription)
{
  if(iIndex>=m_iMapSize)
  {
    return false;
  }
  iValue = m_Map[iIndex].iValue;
  szDescription = m_Map[iIndex].szDescription;
  return true;
}

/*============================================================================*/
/**** Enum Class: Greet ****/
const int Greet::m_iMapSize = 5;
Greet::Map_t Greet::m_Map[] =
{
  {Unknown, "Unknown"},
  {Hello, "Hello"},
  {There, "There !!! "},
  {Bye, " I am going now "},
  {Now, "Now"} 
};

/*----------------------------------------------------------------------------*/
Greet::Greet()
{
  m_Enum = Unknown;
}

/*----------------------------------------------------------------------------*/
Greet::~Greet()
{
}

/*----------------------------------------------------------------------------*/
Greet::Enum Greet::operator=(int i)
{
  m_Enum = AsEnum(i);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
Greet::operator int () const
{
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
Greet::Enum Greet::operator=(const char* sz)
{
  m_Enum = AsEnum(sz);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
bool Greet::operator==(const char* sz)
{
  return m_Enum == AsEnum(sz);
}

/*----------------------------------------------------------------------------*/
Greet::operator const char* () const
{
  return AsName(m_Enum);
}

/*----------------------------------------------------------------------------*/
Greet::Enum Greet::AsEnum(const char* sz)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(strcmp(sz, m_Map[i].szDescription)==0)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
Greet::Enum Greet::AsEnum(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
const char* Greet::AsName(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return m_Map[i].szDescription;
    }
  }
  return m_Map[0].szDescription;
}

/*----------------------------------------------------------------------------*/
bool Greet::GetMap(int iIndex, int& iValue, const char*& szDescription)
{
  if(iIndex>=m_iMapSize)
  {
    return false;
  }
  iValue = m_Map[iIndex].iValue;
  szDescription = m_Map[iIndex].szDescription;
  return true;
}

/*============================================================================*/
/**** Enum Class: Eat ****/
const int Eat::m_iMapSize = 5;
Eat::Map_t Eat::m_Map[] =
{
  {Unknown, "Unknown"},
  {Schnitzel, "Porky"},
  {CafeMocha, "The usual"},
  {Bill, " I am going now "},
  {Money, "Thanks man"} 
};

/*----------------------------------------------------------------------------*/
Eat::Eat()
{
  m_Enum = Unknown;
}

/*----------------------------------------------------------------------------*/
Eat::~Eat()
{
}

/*----------------------------------------------------------------------------*/
Eat::Enum Eat::operator=(int i)
{
  m_Enum = AsEnum(i);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
Eat::operator int () const
{
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
Eat::Enum Eat::operator=(const char* sz)
{
  m_Enum = AsEnum(sz);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
bool Eat::operator==(const char* sz)
{
  return m_Enum == AsEnum(sz);
}

/*----------------------------------------------------------------------------*/
Eat::operator const char* () const
{
  return AsName(m_Enum);
}

/*----------------------------------------------------------------------------*/
Eat::Enum Eat::AsEnum(const char* sz)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(strcmp(sz, m_Map[i].szDescription)==0)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
Eat::Enum Eat::AsEnum(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
const char* Eat::AsName(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return m_Map[i].szDescription;
    }
  }
  return m_Map[0].szDescription;
}

/*----------------------------------------------------------------------------*/
bool Eat::GetMap(int iIndex, int& iValue, const char*& szDescription)
{
  if(iIndex>=m_iMapSize)
  {
    return false;
  }
  iValue = m_Map[iIndex].iValue;
  szDescription = m_Map[iIndex].szDescription;
  return true;
}

/*============================================================================*/
/**** Enum Class: EatNoUnknown ****/
const int EatNoUnknown::m_iMapSize = 5;
EatNoUnknown::Map_t EatNoUnknown::m_Map[] =
{
  {Chop, "Chop"},
  {Schnitzel, "Porky"},
  {CafeMocha, "The usual"},
  {Bill, " I am going now "},
  {Money, "Thanks man"} 
};

/*----------------------------------------------------------------------------*/
EatNoUnknown::EatNoUnknown()
{
  m_Enum = Chop;
}

/*----------------------------------------------------------------------------*/
EatNoUnknown::~EatNoUnknown()
{
}

/*----------------------------------------------------------------------------*/
EatNoUnknown::Enum EatNoUnknown::operator=(int i)
{
  m_Enum = AsEnum(i);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
EatNoUnknown::operator int () const
{
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
EatNoUnknown::Enum EatNoUnknown::operator=(const char* sz)
{
  m_Enum = AsEnum(sz);
  return m_Enum;
}

/*----------------------------------------------------------------------------*/
bool EatNoUnknown::operator==(const char* sz)
{
  return m_Enum == AsEnum(sz);
}

/*----------------------------------------------------------------------------*/
EatNoUnknown::operator const char* () const
{
  return AsName(m_Enum);
}

/*----------------------------------------------------------------------------*/
EatNoUnknown::Enum EatNoUnknown::AsEnum(const char* sz)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(strcmp(sz, m_Map[i].szDescription)==0)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
EatNoUnknown::Enum EatNoUnknown::AsEnum(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return (Enum)m_Map[i].iValue;
    }
  }
  return (Enum)m_Map[0].iValue;
}

/*----------------------------------------------------------------------------*/
const char* EatNoUnknown::AsName(int e)
{
  for(int i=0;i<m_iMapSize;i++)
  {
    if(m_Map[i].iValue == e)
    {
      return m_Map[i].szDescription;
    }
  }
  return m_Map[0].szDescription;
}

/*----------------------------------------------------------------------------*/
bool EatNoUnknown::GetMap(int iIndex, int& iValue, const char*& szDescription)
{
  if(iIndex>=m_iMapSize)
  {
    return false;
  }
  iValue = m_Map[iIndex].iValue;
  szDescription = m_Map[iIndex].szDescription;
  return true;
}

// ------------------------------- eof ------------------------------
